var eventualSafeNodes = function (graph) {
  // 用多个状态来标记各个节点，0表示未遍历过，1表示该点在环里或者递归中处于被遍历过（不安全），2表示该点是安全的
  const n = graph.length
  const color = new Array(n).fill(0)
  const ans = []
  // 依次以每一个结点为出发进行遍历，由于有state数组记录状态，复杂度会低很多
  for (let i = 0; i < n; ++i) {
    if (safe(graph, color, i)) {
      ans.push(i)
    }
  }
  return ans
}

const safe = (graph, color, x) => {
  // 如果该点被遍历过，那么返回该点是否安全
  if (color[x] > 0) {
    return color[x] === 2 // 返回false就是该点为1
  }
  // 先标记该点被遍历过
  color[x] = 1
  // dfs遍历下去，如果该点在环上，则一定会遍历回来，这时候遇到该点state为1，则说明该点不安全，会返回False
  // 只要遇到一条dfs路径有问题，根据题意，都需要返回False来表示该点不安全
  for (const y of graph[x]) {
    // 只要这个节点经过的节点有一个不是安全节点，则他也不是安全节点
    if (!safe(graph, color, y)) {
      return false // return跳出所有循环
    }
  }
  // 如果dfs遍历下去均未遍历回来，则说明该点不在环里，属于安全结点，修改状态并返回True
  // 这个节点经过的节点全都是安全节点，则他也是安全节点
  color[x] = 2
  return true
}
console.log(eventualSafeNodes([[1, 2], [2, 3], [5, 1], [0], [5, 6], [], []])) // [4, 5, 6]
// 我们可以使用深度优先搜索来找环，并在深度优先搜索时，用三种颜色对节点进行标记，标记的规则如下：

// 白色（用 0 表示）：该节点尚未被访问；
// 灰色（用 1 表示）：该节点位于递归栈中，或者在某个环上；
// 黑色（用 2 表示）：该节点搜索完毕，是一个安全节点。
// 当我们首次访问一个节点时，将其标记为灰色，并继续搜索与其相连的节点。

// 如果在搜索过程中遇到了一个灰色节点，则说明找到了一个环，此时退出搜索，栈中的节点仍保持为灰色，这一做法可以将「找到了环」这一信息传递到栈中的所有节点上。
// 如果搜索过程中没有遇到灰色节点，则说明没有遇到环（遇到灰色节点说明遍历过，再连回去就形成了一个环，如果这个节点是安全节点dfs遍历完会把他变成2），那么递归返回前，我们将其标记由灰色改为黑色，即表示它是一个安全的节点。

// 链接：https://leetcode.cn/problems/find-eventual-safe-states/solution/zhao-dao-zui-zhong-de-an-quan-zhuang-tai-yzfz/

// 完整步骤:
/**
访问节点0标记为1；把1标记为1，循环1的节点2,3；将2标记为1，循环2的节点5,1；
5的节点为空直接循环结束将5标记为2，返回true,继续循环回到节点1，节点1在第一步访问过为1，返回false；
此时节点2的子节点有一个return false了，节点2也return false，则退出循环不再遍历节点3，直接return false到根节点0；

访问节点1；1前面被标记为1了，直接return false；

访问节点2；2前面被标记为1了，直接return false；

访问节点3；将3标记为1；3的子节点0 前面被标记为1，直接return false；

访问节点4；将4标记为1；访问4的子节点5，6；5前面标记为2；返回true，继续循环回到节点6，6的节点为空直接循环结束将6标记为2，返回true；
走完节点4的循环，将4标记为2，返回true，将4push到ans数组。

访问节点5；5前面被标记为2了，直接return true，将5 push到ans数组。

访问节点6；6前面被标记为2了，直接return true，将6 push到ans数组。
 */

// 对于题干:大致意思是这样，给你一排点，从0开始按序标号，并且给你每个点的下一访问点的集合，问从某一点出发，
// 对于一个起始节点，如果从该节点出发，无论每一步选择沿哪条有向边行走，最后必然在有限步内到达终点(尽头)，则将该起始节点称作是 安全 的。
// 当一个节点，在某个环内，或者能到达一个环，其是不安全的，道理也很简单，如果遇到环，该节点在环上饶了多少圈不得而知（沿某条路线走可能造成死循环，形成一个环， 题意是任意有向边走都不应该走向循环）
// 也就无法在固定的K步能走到终点
