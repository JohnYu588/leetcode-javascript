/**
 * @param {number} n
 * @return {number}
 */
var climbStairs = function (n) {
  if (n <= 2) {
    return n
  }
  const dp = []
  dp[1] = 1 //1阶台阶,只有一种方式(1)

  //2阶台阶,有两种方式(1+1, 2)
  dp[2] = 2

  //从第三个台阶开始遍历,第三个台阶,是第二个台阶的方法和第一个台阶的方法之和
  //第四个台阶,是第三个台阶和第二个台阶方法之和,依此论推....
  for (let i = 3; i <= n; i++) {
    dp[i] = dp[i - 1] + dp[i - 2] //最后到第n个台阶,得到结果后正好遍历完
  }

  return dp[n]
}
console.log(climbStairs(10))
// 链接：https://leetcode.cn/problems/climbing-stairs/solution/hua-jie-suan-fa-70-pa-lou-ti-by-guanpengchn/
// 标签：动态规划
// 本问题其实常规解法可以分成多个子问题，爬第n阶楼梯的方法数量，等于 2 部分之和

// 爬上 n−1 阶楼梯的方法数量。因为再爬1阶就能到第n阶
// 爬上 n−2 阶楼梯的方法数量，因为再爬2阶就能到第n阶
// 所以我们得到公式 dp[n] = dp[n-1] + dp[n-2](就这两种情况)

/*
如 f(10) = f(9) + f(8)

假设 f(9)有x种情况，f(8)有y种情况
x:
1->2->2->1->1->1->1  |  1
2->1->2->2->1->1     |  1
...

y:
1->2->1->1->1->1->1  |  2
1->1->1->2->1->1->1  |  2
则f(10)= f(9) + f(8) = x(差一步到10级台阶有x种走法)+y(差二步到10级台阶有y种走法)

为什么f(9)和f(8)不会存在相同项因为
x y分别是9级和8级所有走法的集合，当然是不同的。换一个类比的例子，设x为和为9的自然数的集合，y为和为8的自然数集合，那么显然x中的每一项与y中的任何一项都不可能相同。【要么位数不一样，9和8重合（但是9最后会多一个1），要么位数一样【有一位数9是2，8是1】】
*/

// 同时需要初始化 dp[0]=1 和 dp[1]=1
// 时间复杂度：O(n)O(n)

// 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。
// 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？
// 示例 1：

// 输入：n = 2
// 输出：2
// 解释：有两种方法可以爬到楼顶。
// 1. 1 阶 + 1 阶
// 2. 2 阶

// 示例 2：
// 输入：n = 3
// 输出：3
// 解释：有三种方法可以爬到楼顶。
// 1. 1 阶 + 1 阶 + 1 阶
// 2. 1 阶 + 2 阶
// 3. 2 阶 + 1 阶
