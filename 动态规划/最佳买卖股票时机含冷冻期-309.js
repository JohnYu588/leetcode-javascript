// 给定一个整数数组prices，其中第  prices[i] 表示第 i 天的股票价格 。​
// 设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:
// 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。
// 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

// 示例 1:
// 输入: prices = [1,2,3,0,2]
// 输出: 3
// 解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]

// 示例 2:
// 输入: prices = [1]
// 输出: 0
const maxProfit = (prices) => {
  const n = prices.length // n天
  if (n == 0) return 0
  let hold = new Array(n) // 第i天持有股票的最大收益
  let unhold = new Array(n) // 第i天不持有股票的最大收益
  hold[0] = -prices[0] // 第0天买股票，收益-prices[0]元 【这里0是数组下标0，实际是第一天】
  unhold[0] = 0 //  第0天没有持有股票，就是休息，收益 0 元
  for (let i = 1; i < n; i++) {
    if (i == 1) {
      // base case
      hold[i] = Math.max(hold[i - 1], -prices[1]) // 第1天持有着股票，可能是昨天买的，今天休息【如hold[0]=-1】，也可能是昨天休息，今天买的【-price[1]=-2】
    } else {
      hold[i] = Math.max(hold[i - 1], unhold[i - 2] - prices[i])
      // hold[i] : 第 i 天，手中持有股票，这时的最大收益。
      // 有两种可能：
      //1. 昨天就持有股票，今天休息。
      // 2.前天卖了股票，今天买了股票。
    }
    // 手中没有持有股票，第1天和后面没有区别，因为他没有下标-2，持有要计算前天的（第一天没有前天所以要区分）
    unhold[i] = Math.max(unhold[i - 1], hold[i - 1] + prices[i])
    // 第 i 天，手中没有股票，此时的最大收益。
    // 有两种可能：今天休息、或卖了股票
    // 1.昨天也没有持有[卖了股票]，今天休息。
    // 2.昨天持有股票，今天卖了股票。
  }
  return unhold[n - 1] // 目标是求 unhold[n-1] ( n：0 1 2 3 ... )数组最后一条,肯定最后要售出才会交易最大（不然钱烂手里了）
}

console.log(maxProfit([1, 2, 3, 0, 2]))

// 链接：https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/solution/dp-zhuang-tai-de-ding-yi-you-liang-chong-fang-fa-b/

// 动态规划思路
// DP 状态的选择
// 可以用一个三维数组，i 表示天，j 表示是否持有股票，k表示是否是冷冻期
// 也可以用一个二维数组，dp[i][j]：i 表示天，j为 0，1，2：0表示持股，1表示不持股，2表示处于冷冻天
// 也可以用三个一维数组，分别代表第i天，3种选择：卖出、买进、休息，对应的最大收益。
// 也可以按手中是否持有股票，用两个一维数组，分别代表第 i 天，持有和没持有的最大收益
// 也就是说，在选择DP状态的定义时，可以尝试着降维。

// 状态转移方程
// hold[i] : 第 i 天，手中持有股票，这时的最大收益。
// 有两种可能：
// 昨天就持有股票，今天休息。
// 前天卖了股票，今天买了股票。
// hold[i] = Math.max(hold[i - 1], unhold[i - 2] - prices[i])
// unhold[i] : 第 i 天，手中没有股票，此时的最大收益。
// 有两种可能：今天休息、或卖了股票
// 昨天也没有持有，今天休息。
// 昨天持有股票，今天卖了股票。
// unhold[i] = Math.max(unhold[i -1], hold[i - 1] + prices[i])
// 目标是求 unhold[n-1] ( n：0 1 2 3 ... )
// base case
// hold[0] = -prices[0] 第0天买股票，收益-prices[0]元
// hold[1] = Math.max(-prices[0], -prices[1]) 第1天持有着股票，可能是昨天买的，今天休息，也可能是昨天休息，今天买的
// unhold[0] = 0 第0天没有持有股票，就是休息，收益 0 元
// 代码
// 时间复杂度：两个dp数组发生状态转移，花费 O(2n) ，总的来说是 O(n)
